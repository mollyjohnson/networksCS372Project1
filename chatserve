#!/usr/bin/env python3

#although this file doesn't have the .py extension, it is written in python and the above shebang was included
#to make sure it will be run using python3 on the flip server.

#Programmer Name: Molly Johnson (johnsmol)
#Program Name: ClientServerChat
#Program Description: ClientServerChat is my program for completing the requirements of the cs372 Project 1
#Assignment. This program works basically as a chat program between a server on one host (A) and a client on
#another host (B). A connection will be established between host A and host B, and the client
#and server can send messages back and forth to one another until the user (who is controlling
#both the client and server) requests to quit the program, at which point the connection will be closed.
#The server will then remain waiting on the port for any additional connections until a SIGINT is received.
#The name of the server portion of the program is chatserve and the name of the client portion of the program
#is chatclient. 
#Course Name: CS 372 Intro to Networks
#Last Modified: 11/03/19

#imported libraries
from socket import *
import sys

#pre-conditions: none
#post-conditions: number of args will have been checked and the validity of the port argument will have been checked
#description: this function accepts no arguments and returns nothing. Will first check if the correct number of arguments
#has been entered (2, one for the program and one for the port number), then if the number of args is correct the port number
#arg will be checked to make sure it's a non-negative integer, and then if it's a non-negative integer it will be checked to
#make sure that it's not a number above the maximum valid port number possible. If any of these are true (wrong num of args
#entered, negative integer or a string were entered as the port number, or a port number above the allowable range was entered),
#the program will print an error message to the user and exit.
def ArgCheck():
	#should be 2 args, one for program name and one for port number
	if len(sys.argv) != 2:
		print('Wrong number of arguments! Must enter a valid port number. Start the program again.')
		exit()
	#else if there's the right nuber of arguments, make sure the argument is a valid port number.
	#using isdigit() to check if a string represents a non-negative integer adapted from:
	#https://stackoverflow.com/questions/1265665/how-can-i-check-if-a-string-represents-an-int-without-using-try-except
	if sys.argv[1].isdigit() == False:
		print('You entered a negative integer or string for the port number! Must enter a valid port number. Start the program again.')
		exit()
	#if a non-neg integer was entered, check it's in valid port num range. valid port number range: 0-65535
	#valid port values excerpted from:
	#https://www.webopedia.com/quick_ref/portnumbers.asp
	if int(sys.argv[1]) > 65535:
		print('You entered a port number above the valid port number range. Must enter a valid port number. Start the program again.')
		exit()

#pre-conditions: maxMessageSize must be known (in this case we know the max message size is 500 from the assignment instructions, and I
#added one character for the null terminator). Although this parameter isn't passed in as an argument and can instead be defined in the
#function, the max message size must be known ahead of time. serverHandle argument must be a valid string.
#post-conditions: valid input will have been obtained from the user and this input message will be returned.
#description: this function accepts one argument and returns a string message that has been input by the user. Will check that this message
#is valid and if not valid keep looping with an error message and request for new input from the user until a valid message of 500 chars
#or less has been obtained. This validated message will then be returned.
def GetMessage(serverHandle):
	#start validMessage bool to false
	validMessage = False

	#max client handle is 11 (10 + null term), max client message is 501 (500 + null term), added one for additional null term. so will always
	#accommodate a message of up to 500 chars, as specified in the assignment instructions
	maxMessageSize = 513

	#continue to loop and get user input as long as the input is invalid (i.e. validMessage is false)
	while(validMessage == False):
		#get input from the user
		message = input()

		#if the message is below the max size, set validMessage bool to true so breaks out of loop since valid input has been received
		if(len(message) <= maxMessageSize):
			validMessage = True
		#if the message is above the max message size, print an error message to user and reprint handle, so chatserve user can enter
		#a new message
		else:
			print("Message too long. Try again.")
			print(serverHandle + '> ', end = '')

	#return validated message
	return message

#/*
#pre-conditions:
#post-conditions:
#description:
#*/
def SocketSetup(hostAddress, serverPort):
	#all socket server setup adapted from OSU CS 372 lecture 15 slides (specifically, slide 9)
	#and p.205 from Computer Networking-A Top-Down Approach by Kurose and Ross, 7th ed

	#create socket for server (SOCK_STREAM indicates this is a TCP connection)
	serverSocket = socket(AF_INET, SOCK_STREAM)

	#bind the socket to the specified host address and server port
	serverSocket.bind((hostAddress, serverPort))

	#have server start listening for TCP connection requests from clients
	serverSocket.listen(1)

	return serverSocket

#pre-conditions: none, this is the main function of the program
#post-conditions: socket will have been set up, messages received and sent w a client when one connects, and after the connection has been closed
#with that client via the "\quit" command, the server will remain waiting on the host and port number indicated, waiting for any additional client
#connections, until a SIGINT (ctrl-c) is received.
#description: the main function of the program. Calls other functions like ArgCheck() and GetMessage() (see those functions for details), sets the
#server host address and server port (based on command line port argument), performs socket setup and accepts connections, receives/sends data
#to/from the client, upon closing the client connection (\quit entered by either client or the server), will remain on the host and specified port
#number, waiting for any additional client connection requests until a SIGINT (ctrl-c) is received, at which time the program will terminate.
def main():
	#check user entered correct port number argument
	ArgCheck()

	#convert system arg 1 (string) to an int for the server port number
	#getting command line arguments using sys library and argv adapted from:
	#https://stackoverflow.com/questions/4033723/how-do-i-access-command-line-arguments-in-python
	#converting a string to an int adapted from:
	#https://www.digitalocean.com/community/tutorials/how-to-convert-data-types-in-python-3
	serverPort = int(sys.argv[1]) 
	
	#specify host address to a flip server (since not specified in the command line per the assignment instructions and rubric, command line args
	# should just be program name and port number for the server)
	hostAddress = 'flip1.engr.oregonstate.edu'
	
	serverSocket = SocketSetup(hostAddress, serverPort)

	#max message is 501 (500 + 1 for null term), max handle from client is 11 (10 + 1 for null term),
	#gave one extra for handle plus message null term.
	maxMsgPlusHandle = 513

	#hard-coded server handle (okay per the assignment instructions)
	serverHandle = "kermit"

	#continue looping until you get a SIGINT (ctrl-c)
	while True:
		#have server wait for requests
		connectionSocket, addr = serverSocket.accept()

		#receive the prepended handle + message from the client
		clientMessage = connectionSocket.recv(maxMsgPlusHandle).decode()
		#if the client has entered terminating string ("\quit"), print this
		#message but don't send any message back, close the connection socket
		if "\\quit" in clientMessage:
			print(clientMessage)
			connectionSocket.close()
		#if the client didn't request to quit, print their handle + message,
		#then print the server's handle and call GetMessage to get chatserve user input.
		else:
			print(clientMessage)

			#using end='' to prevent the newline from being printed with the print() function adapted from:
			#https://www.stechies.com/python-print-without-newline/
			print(serverHandle + '> ', end = '')

			#call GetMessage to get the user's input for message to send to client
			serverMessage = GetMessage(serverHandle)	

			#send the prepended chatserve handle plus the chatserve user's message to the client
			connectionSocket.send((serverHandle + '> ' + serverMessage).encode())

			#close the socket
			connectionSocket.close()

#used to call the main function
#using a main() function in python adapted from:
#https://www.journaldev.com/17752/python-main-function
if __name__ == '__main__':	
	main()
